# Not the cleanest, nor fastest, nor most understandable way to loop, but
# just to show that it can be done, we use negative number 'skip' to jump
# back in time to form a loop.  This example illustrates, in a small way,
# the way to refactor into smaller words so global flow is better
# understood.

[ loop-setup
  dup dup 9 > ]

[ advance . 1 + ]

[ finish . drop cr ]

[ skiploop
    loop-setup
    3 * skip         # at the end of 'loop-setup', there is a boolean
                     # expression. We use it to get a 'calculated goto'.
                     # Since '1' is 'true', we can multiply this value to
                     # the appropriate number to jump ahead to 'finish'
                     # when true. In this case, we need to skip over 
                     # 'advance -7 skip', which is 3 tokens, so we end up
                     # in the true case with '1 3 * skip', which evaluates
                     # to '3 skip', and in the false case, '0 3 * skip',
                     # which evaluates to '0 skip'

    # false
    advance -7 skip  # since '0 skip' would be the next instruction
                     # ('finish'), '-1 skip' would be 'skip' itself,
                     # '-2 skip' would be '-2' itself, '-3 skip' would
                     # be 'advance', etc. etc. To end up back at
                     # 'loop-setup', therefore, we choose '-7'...

    # true
    finish
]

1 skiploop
